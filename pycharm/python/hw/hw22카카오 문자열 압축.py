# 1.
# 현우는 축구를보다가 우리나라선수들의몸값을 알고싶었다
# 그래서 검색을해서 메모장에 적는데 키보드가 조그만하고 안좋은지라
# 자꾸 숫자가아닌 문자를 같이입력해버린다
# ex: xxx : 1627000000 > xxx : 1w627r00o00p00 만 (특수문자제외)
# 현우는 왜인지모르지만 뜻대로안되는것에
# 너무화가나서 자신이수량을입력하면 문자열만 딱빼서 숫자만 반환하는 코드를 만들고싶어한다
# 화가난 현우를위해 코드를 만들어보자!

# target=input()
# import re
# print("".join(re.findall("\d+",target))+"만원")





# 3. (매우 어려움)
#
# 데이터 처리 전문가가 되고 싶은 “어피치”는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다.
# 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은
# 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는
# 알고리즘을 공부하고 있습니다. 간단한 예로 “aabbaccc”의 경우 “2a2ba3c”(문자가 반복되지 않아 한번만
# 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는
# 단점이 있습니다. 예를 들면, “abcabcdede”와 같은 문자열은 전혀 압축되지 않습니다. “어피치”는 이러한
# 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을
# 찾아보려고 합니다.

# 예를 들어, “ababcdcdababcdcd”의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로
# 잘라서 압축한다면 “2ab2cd2ab2cd”로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면
# “2ababcdcd”로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.
# 다른 예로, “abcabcdede”와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 “abcabc2de”가 되지만,
# 3개 단위로 자른다면 “2abcdede”가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고
# 마지막에 남는 문자열은 그대로 붙여주면 됩니다.
# 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여
# 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.
#
# 제한사항
# s의 길이는 1 이상 1,000 이하입니다.
# s는 알파벳 소문자로만 이루어져 있습니다.
# 입출력 예
# s				result
# "aabbaccc"			7
# "ababcdcdababcdcd"		9
# "abcabcdede"			8
# "abcabcabcabcdededededede"	14
# "xababcdcdababcdcd"		17
#
# 입출력 예에 대한 설명
# 입출력 예 #1 문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다.
# 입출력 예 #2 문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다.
# 입출력 예 #3 문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다.
# 입출력 예 #4 문자열을 2개 단위로 자르면 “abcabcabcabc6de” 가 됩니다. 문자열을 3개 단위로 자르면 “4abcdededededede” 가 됩니다. 문자열을 4개 단위로 자르면 “abcabcabcabc3dede” 가 됩니다. 문자열을 6개 단위로 자를 경우 “2abcabc2dedede”가 되며, 이때의 길이가 14로 가장 짧습니다.
# 입출력 예 #5 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다. 따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다. 이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다.

# s="abcabcabcabcdededededede"
#
# def solution(s):
#     effectlist = [0]
#     k = 1
#     while k <= len(s) // 2:
#         zipeffect = 0
#         j = 0
#         while j < len(s) // k - 1:  # 0,1,2,3,4,5
#             cnt = 1
# #             if len(s) - max(effectlist) < len(str(divmod(len(s[k * j:]), k)[0])) + k + divmod(len(s[k * j:]), k)[1]: break #문자열 길이가 길 떄 넣어주면 좋음
#             for i in range(j+1, (len(s)//k)+1):
#                 if s[k * j:k * (j + 1)] == s[k * (i ):k * (i + 1)]:
#                     cnt += 1
#                     if k == 1:
#                         if cnt == 10 or cnt == 100 or cnt == 1000:pass
#                         elif cnt >= 3:
#                             zipeffect += 1
#                     else:
#                         if cnt == 2:
#                             zipeffect += k - 1
#                         elif cnt == 10 or cnt == 100:
#                             zipeffect += k - 1
#                         elif cnt > 2:
#                             zipeffect += k
#
#                 else:
#                     break
#             j += cnt
#
#         effectlist.append(zipeffect)
#         k += 1
#     answer = len(s) - max(effectlist)
#     return answer
# print(solution(s))



# 4. (매우 어려움)
#
# 친구들로부터 천재 프로그래머로 불리는 “프로도”는 음악을 하는 친구로부터 자신이 좋아하는 노래 가사에
# 사용된 단어들 중에 특정 키워드가 몇 개 포함되어 있는지 궁금하니 프로그램으로 개발해 달라는
# 제안을 받았습니다. 그 제안 사항 중, 키워드는 와일드카드 문자 중 하나인 ‘?’가 포함된 패턴 형태의
# 문자열을 뜻합니다. 와일드카드 문자인 ‘?’는 글자 하나를 의미하며, 어떤 문자에도 매치된다고 가정합니다.
# 예를 들어 "fro??"는 "frodo", "front", "frost" 등에 매치되지만 "frame", "frozen"에는 매치되지
# 않습니다.
# 가사에 사용된 모든 단어들이 담긴 배열 words와 찾고자 하는 키워드가 담긴 배열 queries가 주어질 때,
# 각 키워드 별로 매치된 단어가 몇 개인지 순서대로 배열에 담아 반환하도록 solution 함수를 완성해 주세요.
#
# 가사 단어 제한사항
# words의 길이(가사 단어의 개수)는 2 이상 100,000 이하입니다.
# 각 가사 단어의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다.
# 전체 가사 단어 길이의 합은 2 이상 1,000,000 이하입니다.
# 가사에 동일 단어가 여러 번 나올 경우 중복을 제거하고 words에는 하나로만 제공됩니다.
# 각 가사 단어는 오직 알파벳 소문자로만 구성되어 있으며, 특수 문자나 숫자는 포함하지 않는 것으로 가정합니다.
# 검색 키워드 제한사항


# queries의 길이(검색 키워드 개수)는 2 이상 100,000 이하입니다.
# 각 검색 키워드의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다.
# 전체 검색 키워드 길이의 합은 2 이상 1,000,000 이하입니다.
# 검색 키워드는 중복될 수도 있습니다.


# 각 검색 키워드는 오직 알파벳 소문자와 와일드카드 문자인 '?' 로만 구성되어 있으며,
# 특수 문자나 숫자는 포함하지 않는 것으로 가정합니다.
# 검색 키워드는 와일드카드 문자인 '?'가 하나 이상 포함돼 있으며, '?'는 각 검색 키워드의
# 접두사 아니면 접미사 중 하나로만 주어집니다.
# 예를 들어 "??odo", "fro??", "?????"는 가능한 키워드입니다.
# 반면에 "frodo"('?'가 없음), "fr?do"('?'가 중간에 있음), "?ro??"('?'가 양쪽에 있음)는
# 불가능한 키워드입니다.


# 입출력 예
# words	queries	result
# ["frodo", "front", "frost", "frozen", "frame", "kakao"]	["fro??", "????o", "fr???", "fro???", "pro?"]	[3, 2, 4, 1, 0]
# 입출력 예에 대한 설명
# "fro??"는 "frodo", "front", "frost"에 매치되므로 3입니다.
# "????o"는 "frodo", "kakao"에 매치되므로 2입니다.
# "fr???"는 "frodo", "front", "frost", "frame"에 매치되므로 4입니다.
# "fro???"는 "frozen"에 매치되므로 1입니다.
# "pro?"는 매치되는 가사 단어가 없으므로 0 입니다.

# words=["frodo", "front", "frost", "frozen", "frame", "kakao"]
# queries=["fro??", "????o", "fr???", "fro???", "pro?"]
#
#
# import re
#
#
# for query in queries:
#     cnt=0
#     for word in words:
#         pattern=query.replace("?", "\w")+"$"
#         if re.match(pattern,word):cnt+=1
#     print(cnt)


# print(re.findall(" fro\w\w " ," front afrost frozen frodo "))