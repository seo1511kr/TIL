# 재귀호출

#### 개념

```
1. 함수 속의 함수로 반복적인 작업을 수행함.
2. 수학에서 점화식 같은 느낌으로 보면 됨.
3. 점화식 문제를 푸는 것처럼 반복되는 루틴을 파악하는 것이 중요.
4. 반드시 탈출 조건(예외조건)을 지정하여 조건 달성시 무한루프에서 벗어날 수 있도록 해야함.
5. 데이터 구조의 stack과 유사하여 가장 안쪽의 함수부터 차례대로 호출됨
```

#### ex) fibonacci 수열

```
An= An-1 + An-2
fibo(n)=fibo(n-1)+fibo(n-2) 을 그대로 대응하여 함수를 정의하면 된다

def fibo(n):
	if n < 3: return 1  #재귀 탈출
	return fibo(n-1)+fibo(n-2)
```

#### ex) 하노이탑(https://stricky.tistory.com/155)

```
기둥이 3개일 때 하나의 기둥에서 다른 기둥으로 원판의 크기 조건을 지키며
전부 옮기는 문제 큰 원판은 작은 원판 위로 올 수 없음!
```

##### 1. 구조와 규칙파악: [원래기둥-보조기둥-목표기둥]과 N개의 원반

```
규칙을 자세히 살펴보면 원판의 개수와는 상관없이 항상 가장 밑에 깔려있는 가장 큰 원판을 
옮겨야 될 기둥의 최하단으로 배치해야함.

1. 보조기둥에 N-1개의 원판을 옮겨놓고 
2. 가장큰 원판을 목표기둥으로 옮기고. 
3. 보조기둥에 있는 N-1개의 기둥을 목표기둥으로 옮기는 반복되는 문제에 직면
```

##### 2. 점화식: f(N)=f(N-1)+f(N-1)+1

```
N개의 원판을 옮기기 위한 이동 횟수를 f(N)이라고 하자.

N개의 원판을 옮기기 위한 과정은 N-1개의 원판을 보조기둥으로 옮기는 f(N-1)과

가장큰 원판을 옮기는 1번의 이동, 그리고 보조기둥의 N-1개의 원판을 다시 목표기둥으로 옮기는 f(N-1)의 합이라고 볼 수 있음
```

##### 3. 예외 및 탈출조건 찾기

```
원판이 1개일때: 1회의 이동만 필요함
```

##### 4. 코드로 구현하기

**4-1.개수만 찾기**

```
def hanoi(N):
	if N==1: return N
	return hanoi(N-1)+hanoi(N-1)+1
```

**4-2.경로도 찾기**

```
조금 더 디테일한 규칙을 찾아야함 => 경로 규칙 찾아내야함.
[원기둥->보조기둥, 원기둥->목표기둥, 보조기둥->목표기둥] 순서로 이동.
```

```
N=int(input())
def hanoi(N,start,assist,target):
        if N==1: #경로에서의 예외는 N=1인 경우 뿐

            return [start+" "+target]
        return hanoi(N-1,start,target,assist)+[start+" "+target]+hanoi(N-1,assist,start,target)

print(len(hanoi(N,"1","2","3")))
print("\n".join(hanoi(N,"1","2","3")))
```









